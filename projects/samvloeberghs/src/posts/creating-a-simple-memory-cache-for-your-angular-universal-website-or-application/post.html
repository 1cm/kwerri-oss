<section class="entry-content post-body" itemprop="articleBody">

  <h2>
    <span>
    Target audience
    </span>
  </h2>

  <p>
    This article and guide on <em>setting up a simple memory cache for an Angular Universal website or application</em>
    is targeted to developers that are optimizing their server for better performance. The goal is to
    <em>avoid rerendering the page</em> of the application on the server if there is no need to. Instead we will cache
    the previously generated content and serve it from the cache on subsequent requests.
  </p>

  <p class="alert alert-info">
    <i class="fa fa-info-circle"></i>
    This concept is of course not limited to Angular applications or any other web-application framework or technology
    for that matter. It is a widely adopted <em>common practice for server optimization</em>, to minimize the load on
    the processor. The concepts explained can easily be adopted to your framework or technology of choice.
  </p>

  <h2>
    <span>
    Our example application
    </span>
  </h2>

  <p>
    To explain the basics and prove the concept we have to consider an example application, like for example my simple
    blog, the website you are currently visiting :) This Angular Universal implementation has some <em>static pages
    containing the content in their components, and dynamic pages, loading blogposts from a JSON datasource</em> into
    their components.
  </p>

  <p>
    We have for example the static
    <code><a href="/about" target="_blank">/about</a></code> route and a dynamic blogpost route
    <code><a href="/posts/scroll-to-top-on-angular-router-navigation" target="_blank">/posts/scroll-to-top-on-angular-router-navigation</a></code>`.
    Angular Universal is capable of knowing when the application and blogpost is completely generated.
    <em>As soon as the application is stable, the static HTML is retrieved and send back as the result of the
      request.</em>
  </p>

  <h3>
    <span>Simple diagram for basic rendering</span>
  </h3>

  <img
    src="/posts/creating-a-simple-memory-cache-for-your-angular-universal-website-or-application/universal_basic_render.png"
    alt="Angular Universal : Basic rendering diagram / flow"
    class="extraspace"/>

  <p>
    The diagram above shows the most basic example of the Angular Universal rendering flow. Let's go trough the steps
    shown:
  </p>
  <ol>
    <li>
      The browser requests a specific page from your server, for example the dynamic page
      <code><a href="/posts/scroll-to-top-on-angular-router-navigation" target="_blank">/posts/scroll-to-top-on-angular-router-navigation</a></code>.
    </li>
    <li>
      The server receives the request and renders the Angular application, by fetching the content from the JSON
      datasource.
    </li>
    <li>
      The renderer outputs the static HTML and the server returns this in the response to the browser.
    </li>
  </ol>

  <h3>
    <span>Code for basic rendering</span>
  </h3>

  <p>
    The code for this basic rendering case is available trough the Angular CLI. The <a
    href="https://angular.io/guide/universal" target="_blank" rel="noopener">official documentation on the
    Angular website will get you going really fast</a>. For the sake of this tutorial, the following code and especially
    <em>the highlighted parts</em> are the most important one for our usecase:
  </p>

  <h4 class="codetitle">basic-angular-universal-server-setup.ts</h4>
  <pre data-line="29-57"><code class="language-ts line-numbers">// These are important and needed before anything else
import 'zone.js/dist/zone-node';
import 'reflect-metadata';

import { renderModuleFactory } from '@angular/platform-server';
import {enableProdMode} from '@angular/core';
import * as express from 'express';
import {join} from 'path';
import {readFileSync} from 'fs';

// * NOTE :: leave this as require() since this file is built Dynamically from webpack
const { AppServerModuleNgFactory, LAZY_MODULE_MAP } = require('../../../dist/samvloeberghs/server/main');
const { provideModuleMap } = require('@nguniversal/module-map-ngfactory-loader');

// Faster server renders w/ prod mode
enableProdMode();

// Express server
const app = express();
const PORT = 80;
const DIST_FOLDER = join(process.cwd(), 'server', 'samvloeberghs');

app.set('view engine', 'html');
app.set('views', join(DIST_FOLDER, 'browser'));

// serve static files from /browser
app.get('*.*', express.static(join(DIST_FOLDER, 'browser')));

// Our index.html we'll use as our template
const template = readFileSync(join(DIST_FOLDER, 'browser', 'index.html')).toString();

app.engine('html', (_, options, callback) => {
  renderModuleFactory(AppServerModuleNgFactory, {
    document: template,
    url: options.req.url,
    extraProviders: [
      provideModuleMap(LAZY_MODULE_MAP),
    ],
  }).then(html => {
    callback(null, html);
  });
});

const ngApp = (req, res) => {
  const config = {
    req,
    res,
    preboot: true,
    baseUrl: '/',
    requestUrl: req.originalUrl,
    originUrl: 'https://samvloeberghs.be',
  };

  res.render('index', config);
};

app.get('*', ngApp);

// Start up the Node server
app.listen(PORT, () => {
    console.log(`Node server listening on port ${PORT}`);
});
</code></pre>

  <p>
    <strong>Line 54 is where the actual rendering magic happens</strong>. <code>res.render</code> will return a response
    automatically,
    with the static HTML of the server-side rendered page of your Angular application. Later we will learn how we can
    hook into this.
  </p>
  <p>
    The rest is all Express framework and Universal configuration. If you want to learn more about the code and
    configuration shown above, please <a href="https://www.google.com/search?q=angular+universal" rel="noopener"
                                         target="_blank">follow any tutorial to setup your first Universal application
    in NodeJS</a>. You can
    find some links in the "Further reading" section at the end of the blogpost.
  </p>

  <h2>
    <span>
      Why cache?
    </span>
  </h2>

  <p>
    The content of example routes or pages is very unlikely to change often, so there is absolutely <em>no need to
    render the Angular application each time</em> the page get's requested. We can simply cache the generated HTML on
    the first time visit, store it in a memory cache and retrieve it when the next visitor hits your website.
  </p>
  <p>
    As soon as the content changes, we need to clear the cache and let the cache get regenerated. This will happen the
    first time your updated page gets a visit.
  </p>

  <h2>
    <span>
    A simple memory-cache implementation
    </span>
  </h2>

  <img
    src="/posts/creating-a-simple-memory-cache-for-your-angular-universal-website-or-application/universal_basic_render_cache_mechanism.png"
    alt="Angular Universal : Basic rendering diagram / flow extended with caching mechanism"
    class="extraspace"/>

  <p>
    Let's extend our previous diagram for basic rendering with Universal with a simple cache mechanism.
    The diagram above shows us visually what we need to do to, but let's go trough it step-by-step:
  </p>

  <ol>
    <li>
      The browser requests a specific page from your server, for example the dynamic page
      <code><a href="/posts/scroll-to-top-on-angular-router-navigation" target="_blank">/posts/scroll-to-top-on-angular-router-navigation</a></code>.
    </li>
    <li>
      The server checks if there is a cached version of the page available.
      The first time we visit the page, there is no cached version.
    </li>
    <li>
      The server receives the request and renders the Angular application, by fetching the content from the JSON
      datasource.
    </li>
    <li>
      The server outputs the static HTML and stores it in the cache.
    </li>
    <li>
      The server returns the same static HTML as the response to the browser.
    </li>
    <li>
      The next visitor visits the exact same page.
    </li>
    <li>
      You could already have seem it coming, the server checks again if there is a cached version available and reads it
      from the caching registry.
    </li>
    <li>
      The server returns the cached static HTML as the response to the browser.
    </li>
  </ol>

  <p>
    As you can see, this is no rocket science. It's just a little bit of extra fun work, implementing our simple cache
    and adapting the basic code for server side rendering.
  </p>

  <h3>
    <span>Our simple in-memory caching mechanism</span>
  </h3>

  <p>
    First of all, let's see how <em>our cache implementation</em> would look like. We need a simple CRUD interface to be
    able to <em>update, read and delete our cache entries</em>. By using the package
    <a href="https://www.npmjs.com/package/memory-cache" target="_blank" rel="noopener"><code>memory-cache</code></a>
    we receive the required functionality out of the box! The API is as clear as it can be:
  </p>

  <pre><code class="language-ts line-numbers">const cache = require('memory-cache');

// save a value in the cache
cache.put('foo', 'bar');

// retrieve value from the cache
const cachedValue = cache.get('foo');

// delete key from cache
cache.del('foo');

// clear cache completely
cache.clear();
</code></pre>


  <h3>
    <span>Code for cached rendering</span>
  </h3>

  <h3>
    <span>Cache only the existing pages</span>
  </h3>

  <p>
    <strong>Be careful with what you cache!</strong> You should only cache the pages that actually exist on your
    application or website, or make sense to cache. So <em>avoid the caching of non-existing pages</em>. This could potentially lead to a memory-issue on your server..
  </p>
  <p>
    The only thing a malicious visitor has to do is visit an unlimited amount of unexisting variants
    (<code>/about1</code>, <code>/about2</code>, ... ) of an existing page (<code>/about</code>) and your (memory) cache
    will get flooded. Consequently your server will become very slow and might eventually even crash.

    </p>
  <p>
    A simple way to mitigate this risk is by using (a variant of) your <code>sitemap.xml</code> to whitelist
    the allowed pages. This is implemented on line .. of the code mentioned above.
  </p>

  <h2><span>Possible extensions and improvements</span></h2>

  <p>
    The concepts explained above only touch the basics of implementing a caching strategy and infrastructure.
    There are several improvements possible that I will explain briefly.
  </p>

  <ol>
    <li>
      Generate your static versions at build time
    </li>
    <li>
      Create an interface for your cache
    </li>
    <li>
      Use a seperate caching layer
    </li>
    <li>
      Server-side render only specific pages
    </li>
    <li>
      Use a file based cache instead of memory cache
    </li>
  </ol>

  <h3>
    <span>Generate your static versions at build time</span>
  </h3>

  <p>
    Instead of letting the first visitor of your website be responsible for generating the first cached version
    of specific pages, we can <em>generate the static versions of all the pages of our application at build time</em>.
  </p>
  <p>
    We can do this for example after <a href="https://support.google.com/webmasters/answer/183668?hl=en" target="_blank"
                                        rel="noopener">generating our sitemap.xml</a>. At that point we know all the
    available urls and we can generate the static versions of those pages and put them in the cache.
  </p>

  <h3>
    <span>Create an interface for your cache</span>
  </h3>

  <p>
    Maintaining the cache of a small website like this one is easy. Everytime a new version is availables, I clear the
    cache completely. The first visitor of a specific page is now responsible for creating the cached version.
  </p>

  <p>
    In bigger applications <em>an interface to dynamicaly update and clean the cache</em> is required. For example, when
    using
    a CMS to add a page or blogpost you can trigger a cache-request right after saving the content. If you delete a
    page, you can whipe out the cache, to make sure your visitors are not seeing a page that is already deleted.
  </p>

  <h3>
    <span>Use a seperate caching layer</span>
  </h3>

  <p>
    In this example we have implemented <em>caching at the level of the serving application</em>. This couples our
    server software directly to the caching infrastructure. A more advanced approach would be to install a caching layer
    right before the application server.
  </p>
  <p>
    This can either be a completely different (virtual) machine, or run as an extra service
    on the same machine as the one running our Node.js Express server. This way we can <em>decouple our caching
    infrastructure completely from our serving application</em>.
  </p>

  <h3>
    <span>Server-side render only specific pages</span>
  </h3>

  <h3>
    <span>Use a file based cache instead of memory cache</span>
  </h3>

  <h2><span>Further reading</span></h2>

  <ol class="further-reading">
    <li>
      <a href="https://angular.io/guide/universal" target="_blank"
         rel="noopener">
        Server-side Rendering (SSR): An intro to Angular Universal
      </a>
    </li>
    <li>
      <a href="https://medium.com/@MarkPieszak/angular-universal-server-side-rendering-deep-dive-dc442a6be7b7"
         target="_blank"
         rel="noopener">
        Angular Universal & Server-side rendering Deep-Dive
      </a>
    </li>
    <li>
      <a href="https://support.google.com/webmasters/answer/183668?hl=en"
         target="_blank" rel="noopener">
        Manage your sitemaps - Build and submit a sitemap
      </a>
    </li>
  </ol>

  <h2>
    <span>
      Special thanks to
    </span>
  </h2>

  <ul>
    <li>
      <a href="" rel="noopener" target="_blank">

      </a>
    </li>
  </ul>

  <p>for reviewing this post and providing valuable and much-appreciated feedback!</p>

</section>

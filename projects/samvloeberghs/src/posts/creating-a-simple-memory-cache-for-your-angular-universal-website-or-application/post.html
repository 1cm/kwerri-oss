<section class="entry-content post-body" itemprop="articleBody">

  <h2>
    <span>
    Target audience
    </span>
  </h2>

  <p>
    This article and guide on <em>setting up a simple memory cache for an Angular Universal website or application</em>
    is targeted to developers that are optimizing their server for better performance. The goal is to
    <em>avoid rerendering the page</em> of the application on the server if there is no need to. Instead we will cache
    the previously generated content and serve it from the cache on subsequent requests.
  </p>

  <p class="alert alert-info">
    <i class="fa fa-info-circle"></i>
    This concept is of course not limited to Angular applications or any other web-application framework or technology
    for that matter. It is a widely adopted <em>common practice for server optimization</em>, to minimize the load on
    the processor. The concepts explained can easily be adopted to your framework or technology of choice.
  </p>

  <h2>
    <span>
    Our example application
    </span>
  </h2>

  <p>
    To explain the basics and prove the concept we have to consider an example application, like for example my simple
    blog, the website you are currently visiting :) This Angular Universal implementation has some <em>static pages
    containing the content in their components, and dynamic pages, loading blogposts from a JSON datasource</em> into
    their components.
  </p>

  <p>
    We have for example the static
    <code><a href="/about" target="_blank">/about</a></code> route and a dynamic blogpost route
    <code><a href="/posts/scroll-to-top-on-angular-router-navigation" target="_blank">/posts/scroll-to-top-on-angular-router-navigation</a></code>`.
    Angular Universal is capable of knowing when the application and blogpost is completely generated.
    <em>As soon as the application is stable, the static HTML is retrieved and send back as the result of the
      request.</em>
  </p>

  <h3>
    <span>Simple diagram for basic rendering</span>
  </h3>

  <img
    src="/posts/creating-a-simple-memory-cache-for-your-angular-universal-website-or-application/universal_basic_render.png"
    alt="Angular Universal : Basic rendering diagram / flow"
    class="extraspace"/>

  <p>
    The diagram above shows the most basic example of the Angular Universal rendering flow. Let's go trough the steps
    shown:
  </p>
  <ol>
    <li>
      The browser requests a specific page from your server, for example the dynamic page
      <code><a href="/posts/scroll-to-top-on-angular-router-navigation" target="_blank">/posts/scroll-to-top-on-angular-router-navigation</a></code>.
    </li>
    <li>
      The server receives the requests and renders the Angular application, by fetching the content from the JSON
      datasource.
    </li>
    <li>
      The renderer outputs the static HTML and the server returns this in the response to the browser.
    </li>
  </ol>

  <h3>
    <span>Code for basic rendering</span>
  </h3>

  <p>
    The code for this basic rendering case is available trough the Angular CLI. The <a
    href="https://angular.io/guide/universal" target="_blank" rel="noopener">official documentation on the
    Angular website will get you going really fast</a>. For the sake of this tutorial, the following code is the
    most important one for our usecase:
  </p>

  <h4 class="codetitle">basic-angular-universal-setup.ts</h4>
  <pre><code class="language-ts">app.engine('html', ngExpressEngine({
  bootstrap: AppServerModuleNgFactory,
  providers: [
    provideModuleMap(LAZY_MODULE_MAP)
  ]
}));

// All regular routes use the Universal engine
app.get('*', (req, res) => {
  res.render('index', { req });
});
</code></pre>

  <h2>
    <span>
      Why cache?
    </span>
  </h2>

  <p>
    The content of these pages is very unlikely to change often, so there is absolutely <em>no need to render the
    Angular application each time</em> the page get's requested. We can simply cache the generated HTML on the first
    time visit,
    store it in a memory cache and retrieve it when the next visitor hits your website.
  </p>
  <p>
    As soon as the content changes, we need to clear the cache and let the cache get regenerated. This will happen the
    first time your updated page gets a visit.
  </p>

  <h2>
    <span>
    A simple memory-cache implementation
    </span>
  </h2>

  <img
    src="/posts/creating-a-simple-memory-cache-for-your-angular-universal-website-or-application/universal_basic_render_cache_mechanism.png"
    alt="Angular Universal : Basic rendering diagram / flow extended with caching mechanism"
  class="extraspace"/>

  <p>
    Let's extend our previous diagram for basic rendering with Universal with a simple cache mechanism.
    The diagram above shows us visually what we need to do to, but let's go trough it step-by-step:
  </p>

  <ol>
    <li>
      The browser requests a specific page from your server, for example the dynamic page
      <code><a href="/posts/scroll-to-top-on-angular-router-navigation" target="_blank">/posts/scroll-to-top-on-angular-router-navigation</a></code>.
    </li>
    <li>
      The server checks if there is a cached version of the page available.
      The first time we visit the page, there is no cached version.
    </li>
    <li>
      The server receives the request and renders the Angular application, by fetching the content from the JSON
      datasource.
    </li>
    <li>
      The server outputs the static HTML and stores it in the cache.
    </li>
    <li>
      The server returns the same static HTML as the response to the browser.
    </li>
    <li>
      The next visitor visits the exact same page.
    </li>
    <li>
      You could already have seem it coming, the server checks again if there is a cached version available and reads it
      from the caching registry.
    </li>
    <li>
      The server returns the cached static HTML as the response to the browser.
    </li>
  </ol>

  <p>
    As you can see, this is no rocket science. It's just a little bit of extra fun work, implementing our simple cache
    and adapting the basic code for server side rendering.
  </p>

  <h3>
    <span>Code for simple caching mechanism</span>
  </h3>

  <h2><span>Possible extensions and improvements</span></h2>

  <p>
    The concepts explained above only touch the basics of implementing a caching strategy and infrastructure.
    There are several improvements possible that I will explain briefly.
  </p>

  <ol>
    <li>
      Generate your static versions at build time
    </li>
    <li>
      Create an interface for your cache
    </li>
    <li>
      Use a seperate caching layer
    </li>
  </ol>

  <h3>
    <span>Generate your static versions at build time</span>
  </h3>

  <p>
    Instead of letting the first visitor of your website be responsible for generating the first cached version
    of specific pages, we can <em>generate the static versions of all the pages of our application at build time</em>.
  </p>
  <p>
    We can do this for example after <a href="https://support.google.com/webmasters/answer/183668?hl=en" target="_blank"
                                        rel="noopener">generating our sitemap.xml</a>. At that point we know all the
    available urls and we can generate the static versions of those pages and put them in the cache.
  </p>

  <h3>
    <span>Create an interface for your cache</span>
  </h3>

  <p>
    Maintaining the cache of a small website like this one is easy. Everytime a new version is availables, I clear the
    cache completely. The first visitor of a specific page is now responsible for creating the cached version.
  </p>

  <p>
    In bigger applications <em>an interface to dynamicaly update and clean the cache</em> is required. For example, when
    using
    a CMS to add a page or blogpost you can trigger a cache-request right after saving the content. If you delete a
    page, you can whipe out the cache, to make sure your visitors are not seeing a page that is already deleted.
  </p>

  <h3>
    <span>Use a seperate caching layer</span>
  </h3>

  <p>
    In this example we have implemented <em>caching at the level of the serving application</em>. This couples our
    server software directly to the caching infrastructure. A more advanced approach would be to install a caching layer
    right before the application server.
  </p>
  <p>
    This can either be a completely different (virtual) machine, or run as an extra service
    on the same machine as the one running our Node.js Express server. This way we can <em>decouple our caching
    infrastructure completely from our serving application</em>.
  </p>

  <h2><span>Further reading</span></h2>

  <ol class="further-reading">
    <li>
      <a href="" target="_blank"
         rel="noopener">

      </a>
      <a href="https://support.google.com/webmasters/answer/183668?hl=en"
         target="_blank" rel="noopener">
        Manage your sitemaps - Build and submit a sitemap
      </a>
    </li>
  </ol>

  <h2>
    <span>
      Special thanks to
    </span>
  </h2>

  <ul>
    <li>
      <a href="" rel="noopener" target="_blank">

      </a>
    </li>
  </ul>

  <p>for reviewing this post and providing valuable and much-appreciated feedback!</p>

</section>

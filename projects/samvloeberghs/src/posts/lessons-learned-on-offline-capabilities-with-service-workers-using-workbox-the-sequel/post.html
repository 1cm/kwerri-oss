<section class="entry-content post-body" itemprop="articleBody">

  <h2>
    <span>
    Target audience
    </span>
  </h2>

  <p>
    This is a follow-up on my
    <a href="/posts/lessons-learned-on-offline-capabilities-with-service-workers-using-workbox">previous article about
      lessons learned on offline capabilities using Workbox</a>. This article highlights some more findings and explores
    better/other solutions for the problems described earlier.
  </p>

  <h2>
    <span>
    What will we discuss in this post?
    </span>
  </h2>

  <ol>
    <li>Better detection for first install with service worker</li>
    <li>Updating the application while using it</li>
  </ol>

  <p>
    All the example code used in this post, just as this complete website, is
    <a href="https://github.com/samvloeberghs/kwerri-oss" target="_blank" rel="noopener">available on Github here</a> as
    an example project for you to test and try-out.
  </p>

  <h2>
    <span>
     Better detection for first install with service worker
    </span>
  </h2>

  <p>
    In my <a href="/posts/lessons-learned-on-offline-capabilities-with-service-workers-using-workbox">previous post
    about service workers and Workbox</a> I used a somewhat shady technique with a refresh to activate the service
    worker functionality on the first load of the application. <em>This is completely unnecessary</em>
    and the outcome can be achieved using other techniques.
  </p>

  <p>
    If we consider the code to register the service worker from the previous post, the only thing we have to change is
    send an event to the service worker, to claim the clients instead of reloading the page. This is demonstrated on
    line 18 and 23 in the following code. The logic to detect a first service worker remained unchanged.
  </p>

  <h4 class="codetitle">service-worker-registration.ts</h4>
  <pre data-line="18,23"><code class="language-ts line-numbers">// Check that service workers are available
if ('serviceWorker' in navigator) {
  // Use the window load event to keep the page load performant
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js').then(registration => {
      if (navigator.serviceWorker.controller) {
        // let the application know our service worker is ready
        window['serviceWorkerReady'] = true;
        window.dispatchEvent(new CustomEvent('service-worker-ready'));
      }

      // A wild service worker has appeared in reg.installing and maybe in waiting!
      const newWorker = registration.installing;
      const waitingWoker = registration.waiting;

      if (newWorker) {
        if (newWorker.state === 'activated' && !waitingWoker) {
          newWorker.postMessage({ type: 'CLIENTS_CLAIM' });
        }
        newWorker.addEventListener('statechange', () => {
          // newWorker.state has changed
          if (newWorker.state === 'activated' && !waitingWoker) {
            newWorker.postMessage({ type: 'CLIENTS_CLAIM' });
          }
        });
      }
    })
    .catch(err => {
    console.log('service worker could not be registered', err);
    });
  });
}
</code></pre>

  <p>
    For this to work we need to make our service worker react to messages and claim the clients for this installation
    of the service worker. We do this by registering an event listener on the <code>message</code> event:
  </p>

  <h4 class="codetitle">service-worker.js</h4>
  <pre data-line="5"><code class="language-js line-numbers">// ... other sw functionality

self.addEventListener('message', event => {
    if (event.data && event.data.type === 'CLIENTS_CLAIM') {
    self.clients.claim();
  }
});
</code></pre>

  <p>
    If a service worker is installed, but not controlling the page yet, an event that matches the type
    <code>CLIENTS_CLAIM</code> will claim the clients and activate the service worker for those clients.
  </p>

  <h3>
    <span>Using Workbox Window to solve the same problem</span>
  </h3>

  <p>
    With Workbox Window we can listen for the <code>activated</code> event on the service worker registration.
    This events holds a property <code>isUpdate</code> that indicates if a previous version was controlling the page.
    If not, we can assume this is a first time install.
  </p>

  <h4 class="codetitle">service-worker-registration-workbox-window.ts</h4>
  <pre data-line="8,14"><code class="language-ts line-numbers">import { Workbox } from 'workbox-window';

const wb = new Workbox('/service-worker.js', {});

wb.addEventListener('activated', async event => {
  // `event.isUpdate` will be true if another version of the service
  // worker was controlling the page when this version was registered.
  if (!event.isUpdate) {
    // If your service worker is configured to precache assets, those
    // assets should all be available now.
    // So send a message telling the service worker to claim the clients
    // This is the first install, so the functionality of the app
    // should meet the functionality of the service worker!
    wb.messageSW({ type: 'CLIENTS_CLAIM' });
  }
});

wb.register();
</code></pre>

  <p>
    Similar to our previous example, without Workbox Window, our service worker needs to be listening to messages and
    act accordingly on the message of type <code>CLIENTS_CLAIM</code>. <code>wb.messageSW</code> is a wrapper function
    that provides a message and reply mechanism using a <code>MessageChannel</code> but also just send a message to the
    service worker using <code>postMessage</code>.
  </p>

  <h2>
    <span>
     Updating the application while using it
    </span>
  </h2>

  <p>
    With PWA's installed on the homescreeen and opened as native-like applications it's possible that those
    <em>applications are opened for a long time</em>. Updating a new version of the application and installing a new
    service worker could potentially by extended or postponed for a long time, until the user closes and reopens the
    application, or refreshes. It's even <a href="https://developers.google.com/web/updates/2017/11/overscroll-behavior" rel="noopener"
                            target="_blank">possible to disable the refresh by pulling down the application
    completely</a>.
  </p>
  <p>
    In those cases the only way of updating seems to be closing and reopening the application. <strong>Fortunately it's
    not</strong>. There are several ways of doing an update in-application: by means of <em>user-intent</em>, when the
    <em>application becomes visible</em> again or by <em>setting up an interval</em>. Let's explore these 3 options.
  </p>

  <h3>
    <span>Update application by user-intent</span>
  </h3>

  <p>
    The simplest way of asking for an update to the application is by <em>letting the user click a button</em>. So we are gonna
    take this example to show how to update the application while running it. The other options and examples are just
    defining a different approach or intent to update.
  </p>

  <p>
    To be able to update our application while running it we need to make sure that we are keeping the original
    registration. Checking for a new version and performing an update is then as simple as just calling
    <code>swRegistration.update()</code>. Consider the following <code>ServiceWorkerService</code>:
  </p>

  <pre data-line="9,18,28"><code class="language-ts line-numbers">import { Injectable } from '@angular/core';
import { Workbox } from 'workbox-window';

@Injectable({
  providedIn: 'root',
})
export class ServiceWorkerService {

  private swRegistration: ServiceWorkerRegistration;

  constructor() {
    this.registerServiceWorker();
  }

  public async checkForUpdate() {
    try {
      console.log('updating sw');
      return await this.swRegistration.update();
    } catch (err) {
      console.log('sw.js could not be updated', err);
    }
  }

  private async registerServiceWorker() {
    const wb = new Workbox('/sw.js', {});

    try {
      this.swRegistration = await wb.register();
    } catch (e) {
      console.log('error registering service worker', e);
    }
  }

}</code></pre>

  <p>
    This Angular example service, <em>which can BTW be easily ported to any framework</em>, registers the service worker as soon
    as the service gets instantiated. The <code>register</code> method call on the Workbox instance gives us a native
    <code>ServiceWorkerRegistration</code> that we save in the <code>serviceWorkerRegistration</code> property.
  </p>

  <p>
    Now any button in the application can be coupled to check for an update of the application by calling the
    <code>checkForUpdate method</code>. This method uses the previously saved registration and calls <code>update</code>
    on it.
  </p>
  <p>
    The <code>update</code> method tries to update the service worker by fetching the registration's URL. In case there
    is a <em>byte-by-byte difference</em> to the current service worker, the new service worker will ge installed and
    eventually will go in a waiting state, after its potential new resources have been cached and the logic has been
    loaded.
  </p>

  <h3>
    <span>Handling the new but waiting service worker</span>
  </h3>

  <p>
    Whenever our application gets a hold of a new but waiting service worker, we can safely assume that our application
    can be updated. So we show a message to the user that an action, like refreshing the page, can be invoked to load
    the new functionality. By using this approach we <em>keep the responsibility with the user</em> to load the new version.
  </p>

  <p class="alert alert-warning">
    <i class="fa fa-exclamation-circle"></i>
    Immediately activating the new service worker, by using <code>skipWaiting()</code> and/or <code>clients.claim()</code>
    for all the clients when it becomes waiting can potentially break your application. The functionality from the new
    service worker could not be compatible with the currently loaded old version of your application.
    <a href="/posts/lessons-learned-on-offline-capabilities-with-service-workers-using-workbox">Read more about this consideration in my previous blogpost</a>.
  </p>

  <h3>
    <span>Update application when it becomes visible again</span>
  </h3>

  <p>
    Another strategy to try and update your application can be <em>based on the visibility of your application</em>. As
    soon as your functionality is loaded, we can start listening to the <code>visibilitychange</code> event on the
    <code>document</code> as shown in the highlighted code below.
  </p>

  <pre data-line="14,36-40"><code class="language-ts line-numbers">import { Injectable } from '@angular/core';
import { Workbox } from 'workbox-window';
import { fromEvent } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class ServiceWorkerService {

 private swRegistration: ServiceWorkerRegistration;

  constructor() {
    this.registerServiceWorker();
    this.registerVisibileChangeListener();
  }

  public async checkForUpdate() {
    try {
      console.log('updating sw');
      return await this.swRegistration.update();
    } catch (err) {
      console.log('sw.js could not be updated', err);
    }
  }

  private async registerServiceWorker() {
    const wb = new Workbox('/sw.js', {});

    try {
      this.swRegistration = await wb.register();
    } catch (e) {
      console.log('error registering service worker', e);
    }
  }

  private registerVisibileChangeListener() {
    fromEvent(document, 'visibilitychange').subscribe(() => {
      this.checkForUpdate();
    });
  }

}
</code></pre>

  <p>
    Now every time your application gets hidden, for example when opening a new tab in your browser or opening a new
    application on your smartphone, and you choose to make the tab visible again, or you reopen the application, the
    app will try to update the service worker.
  </p>

  <h3>
    <span>Update application by setting up an interval</span>
  </h3>

  <p>
    One more other strategy is <em>requesting an update on an interval</em>, for example every 4 hours.
    The extra logic / code for this is a simple 3-liner as highlighted below:
  </p>

  <pre data-line="31-33"><code class="language-ts line-numbers">import { Injectable } from '@angular/core';
import { Workbox } from 'workbox-window';

@Injectable({
  providedIn: 'root',
})
export class ServiceWorkerService {

  private readonly swUpdateInterval = 4 * 60 * 60 * 1000; // 4h
  private swRegistration: ServiceWorkerRegistration;

  constructor() {
    this.registerServiceWorker();
  }

  public async checkForUpdate() {
    try {
      console.log('updating sw');
      return await this.swRegistration.update();
    } catch (err) {
      console.log('sw.js could not be updated', err);
    }
  }

  private async registerServiceWorker() {
    const wb = new Workbox('/sw.js', {});

    try {
      this.swRegistration = await wb.register();

      setInterval(async () => {
        this.checkForUpdate();
      }, this.swUpdateInterval);
    } catch (e) {
      console.log('error registering service worker', e);
    }
  }

}
</code></pre>

  <h2>
    <span>
    Conclusion
    </span>
  </h2>

  <p>
    Today we learned a better way of controlling the application with our service worker on the very first load. Instead
    of refreshing we use the <code>clients.claim()</code> method, but in a way that we won't potentially break our
    application.
  </p>

  <p>
    Furthermore, we have explored a few ideas on how to update our application from within the application. This is
    particularly useful if our applications are long-living and we want to make sure our users get the latest
    functionalities.
  </p>

  <p>
    Workbox and service workers in general still have many unknown capabilities that I'm learning about. But while we
    keep developing we explore new ideas and ways of optimizing our code. I think I will be writing more about service
    workers in the future :)
  </p>

  <h2><span>Further reading</span></h2>

  <ol class="further-reading">
    <li>
      <a href="https://developers.google.com/web/tools/workbox/modules/workbox-window"
         target="_blank" rel="noopener">
        Workbox Window documentation
      </a>
    </li>
    <li>
      <a
        href="https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading"
        target="_blank" rel="noopener">
        High-performance service worker loading
      </a>
    </li>
    <li>
      <a href="https://developers.google.com/web/updates/2017/11/overscroll-behavior"
         target="_blank" rel="noopener">
        Take control of your scroll: customizing pull-to-refresh and overflow effects
      </a>
    </li>
    <li>
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/update"
         target="_blank" rel="noopener">
        ServiceWorkerRegistration documentation
      </a>
    </li>
  </ol>

  <!--
  <h2>
    <span>
      Special thanks to
    </span>
  </h2>

  <ul>
    <li>
      <a href="" rel="noopener" target="_blank">

      </a>
    </li>
  </ul>

  <p>
    for reviewing this post and providing valuable and much-appreciated feedback! I'm open for any other feedback so
    please let me know!
  </p>
  -->

</section>

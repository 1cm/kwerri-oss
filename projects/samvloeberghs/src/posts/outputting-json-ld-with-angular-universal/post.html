<section class="entry-content post-body" itemprop="articleBody">

  <h2>
    <span>
    Target audience
    </span>
  </h2>

  <p>
    This article and guide on generating JSON-LD with Angular Universal is targeted to developers that want to generate
    the JSON that represents the Linked Data object and inject it correctly in the HTML that gets generated on the
    server.
  </p>

  <h2>
    <span>
    First of all; What is JSON-LD?
    </span>
  </h2>

  <p>
    JSON-LD is a lightweight Linked Data format. It is easy for humans to read and write. It is based on the already
    successful JSON format and provides a way to help JSON data interoperate at Web-scale.
  </p>

  <p>
    <a href="https://en.wikipedia.org/wiki/Linked_data" target="_blank" rel="noopener">Linked Data</a> empowers people
    that publish and use information on the Web. It is a way to create a network of standards-based, machine-readable
    data across Web sites. It allows an application to start at one piece of Linked Data, and follow embedded links to
    other pieces of Linked Data that are hosted on different sites across the Web.
  </p>

  <p class="alert alert-info">
    <i class="fa fa-info-circle"></i>
    These 2 <em>definitions of JSON-LD and Linked Data</em> were simply taken from the website of JSON-LD. This article
    does not go deep into the full specification of JSON-LD and it does not teach you how to properly
    generate your Linked Data structures. The tools of the <a href="https://json-ld.org" target="_blank" rel="noopener">JSON-ld
    website</a>, like for example the <a href="https://json-ld.org/playground/" target="_blank" rel="noopener">playground</a>,
    give you all you need to validate your Linked Data structures.
  </p>

  <h3>
    Why should I care about JSON-LD?
  </h3>

  <p>
    You should care about JSON-LD for several reasons:
  </p>
  <ul>
    <li>
      It's simpler to generate, more structured and easier to read than <a href="https://schema.org/docs/gs.html"
                                                                           target="_blank" rel="noopener">Microdata</a>
    </li>
    <li>
      It links or allows your data to be linked with other entities / data subjects on the world-wide web
    </li>
  </ul>

  <p>
    In general; it ads a lot <em>more semantic value to your HTML markup</em> by providing context to what you show on
    the page and makes this context machine-readable, allowing it to be <em>parsed more easily by search engines and
    other crawlers</em> on the web.
  </p>

  <h2>
    <span>
    Generating your JSON Linked Data structure
    </span>
  </h2>

  <p>
    In the simple case of a blog or not too complex website, generating your JSON Linked Data can be done using the same
    base data you use to set your meta tags for social sharing and SEO. <em>Your most important concern is building the
    correct structure</em>. How your structure looks is completely dependent on your usecase. As a basic example we will
    use this website, and more specifically the <a href="https://samvloeberghs.be/about">about page</a>.
  </p>

  <p>
    Using the router we first define the correct SEO data associated with our route. Just like we did before, <a
    href="https://samvloeberghs.be/posts/better-sharing-on-social-media-platforms-with-angular-universal">setting the
    correct social share meta tags</a>.
  </p>

  <pre><code class="typescript highlighted">RouterModule.forChild([{
    path: '',
    component: AboutComponent,
    data: {
      seo: {
        title: `About Sam - ${environment.seo.title}`,
        description: `I'm a 30 year old software engineer living in Belgium.`,
        shareImg: '/assets/share/about.png',
      }
    }
}])</code></pre>

  <p>
    Using a service we can subscribe to route changes to extract this data and pass the data to a service to parse the
    JSON-LD object.
  </p>

  <pre><code class="typescript highlighted">@Injectable({
    providedIn: 'root',
})
export class Routehelper {

  constructor(
    private readonly router: Router,
    private readonly activatedRoute: ActivatedRoute,
    private readonly jsonLdService: JsonLdService
  ) {
    this.setupRouting();
  }

  private setupRouting() {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd),
      map(() => this.activatedRoute),
      map(route => {
        while (route.firstChild) {
          route = route.firstChild;
        }
        return route;
      }),
      filter(route => route.outlet === 'primary')
    ).subscribe((route: ActivatedRoute) => {
      const seo = route.snapshot.data['seo'];
      // generate your JSON-LD object here
      const jsonLd = {
        name: seo.title,
        url: environment.url + this.router.routerState.snapshot.url,
      };
      this.jsonLdService.setData('Website', jsonLd);
    });
  }

}</code></pre>

  <p>
    The <code>JsonLdService</code> injected above is a simple service that caches and updates the data structure we need
    to output. A basic implementation of this service can be as follows, where you as a developer are still in charge of
    correctly structuring your object.
  </p>

  <pre><code class="typescript highlighted">@Injectable({
  providedIn: 'root',
})
export class JsonLdService {

  private jsonLd: any = {};

  setData(type: string, rawData: any) {
    this.jsonLd = this.getObject(type, rawData);
  }

  getObject(type: string, rawData?: any) {
    let object = {
      '@context': 'http://schema.org',
      '@type': type,
    };
    if (rawData) {
      object = Object.assign({}, object, rawData);
    }
    return object;
  }

  toJson() {
    return JSON.stringify(this.jsonLd);
  }
}</code></pre>

  <p>
    Using the approach explained above our current JSON-LD data-object in memory will look like this:
  </p>

  <pre><code class="json highlighted">{
    "@context": "http://schema.org",
    "@type": "Website",
    "name": "About Sam - Sam Vloeberghs - Freelance Webdeveloper & Software Engineer",
    "url": "https://samvloeberghs.be/about"
}</code></pre>

  <p>This basic example is what we wanted to achieve. The next step is getting this object outputted in our static
    HTML.</p>

  <h2>
    <span>
    Injecting the JSON in the static HTML
    </span>
  </h2>

  <h3>
    Getting inspiration in the Angular source code
  </h3>

  <p>
    Injecting the JSON-LD data object in the DOM is only really required when we generate the HTML on the server. To
    get to this result I looked into the <a
    href="https://github.com/angular/angular/blob/master/packages/platform-browser/src/browser/transfer_state.ts"
    rel="noopener" target="_blank"><code>BrowserTransferStateModule</code></a> exposed via the <code>@angular/platform-browser</code>
    module.
  </p>
  <p>
    Essentialy this module, and more particullary, the <a
    href="https://github.com/angular/angular/blob/master/packages/platform-browser/src/browser/transfer_state.ts"
    target="_blank" rel="noopener"><code>TransferState</code></a> service it provides, does the same
    thing we want to achieve. It caches data, the result from for example HTTP calls, in an object and holds
    it in memory during the application lifecycle. Apart from the HTTP calls, that's exactly what our <code>JsonLdService</code>
    does.
  </p>

  <p>
    The server counter part, <a
    href="https://github.com/angular/angular/blob/master/packages/platform-server/src/transfer_state.ts"><code>ServerTransferStateModule</code></a>
    exposed via the <code>@angular/platform-server</code>, serializes the data and injects it in the DOM before
    generating the HTML on the server and sending it back over the wire to the browser. Again, that is exactly what we
    want to achieve. This is achieved by providing an extra factory function to the <code>BEFORE_APP_SERIALIZED</code>
    token. Right after the application becomes stable all factories attached to the <code>BEFORE_APP_SERIALIZED</code>
    are executed.
  </p>

  <p>
    When the Angular application bootstraps in the browser, the <code>TransferState</code> service picks up the
    serialized state in the static HTML and unserializes it, making it available as a direct cache. This way we avoid
    that the application makes a similar request for the same data to the server, for which the server-side-rendered
    version already did the call. We don't need this part, but it's good to know. Check the <a
    href="https://github.com/angular/angular/blob/master/packages/platform-browser/src/browser/transfer_state.ts#L140-L153"
    target="_blank" rel="noopener">source code</a> to see how it works :).
  </p>

  <h3>
    Our simple BrowserJsonLdModule and ServerJsonLdModule
  </h3>

  <p>
    Following the concepts and ideas we learned from the <code>ServerTransferStateModule</code> and the <code>BrowserTransferStateModule</code>
    we create our own <code>ServerJsonLdModule</code> and <code>BrowserJsonLdModule</code>. The only small differences
    are limited to changing the type of the <code>&#x3C;script&#x3E;</code> element and injecting it in the <code>&#x3C;head&#x3E;</code>
    instead
    of right before the <code>&#x3C;/body&#x3E;</code> tag.
  </p>

  <pre><code class="typescript highlighted">import { NgModule } from '@angular/core';
import { JsonLdService } from './jsonld.service';

@NgModule({
  providers: [
    JsonLdService,
  ]
})
export class BrowserJsonLdModule {
}</code></pre>

  <pre><code class="typescript highlighted">import { NgModule } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { BEFORE_APP_SERIALIZED } from '@angular/platform-server';
import { JsonLdService } from './jsonld.service';

export function serializeJsonLdFactory(doc: Document, jsonLdService: JsonLdService) {
  const serializeAndInject = function () {
    const script = doc.createElement('script');
    script.setAttribute('type', 'application/ld+json');
    script.textContent = jsonLdService.toJson();
    doc.head.appendChild(script);
  };
  return x;
}

@NgModule({
  providers: [
    JsonLdService, {
    provide: BEFORE_APP_SERIALIZED,
      useFactory: serializeJsonLdFactory,
      deps: [DOCUMENT, JsonLdService],
      multi: true,
    },
  ],
})
export class ServerJsonLdModule {
}</code></pre>


  <h2>
    <span>
      Differentiate execution on the server
    </span>
  </h2>

  <p>
    To differentiatie the execution of our application on the server versus on the browser, we create a new server
    module <code>app.server.module.ts</code> next to <code>app.module.ts</code> that will directly import the <code>AppModule</code>
    exported by <code>app.module.ts</code>.
  </p>
  <p>
    If we go back to the example of the <code>TransferState</code> service, we see that the
    <code>app.server.module.ts</code> is importing the <code>ServerTransferStateModule</code>.
    This will overwrite the provider of the <code>ServerTransferStateModule</code> imported in the app.module.ts and
    provide the serialize functionality.
  </p>

  <h2>
    <span>
    Conclusion
    </span>
  </h2>

  <p>
    Generating JSON-LD using Angular Universal is pretty straight-forward. By borrowing concepts from the Angular source
    code we can create our own JsonLdModules and services that enable us to output JSON-LD in the static generated HTML
    on the server. The result of this code can be found live on this website, just look at the source and do a hard
    refresh. Why a hard refresh you might ask? Because of the service worker caching the default index.html as the app
    shell.
  </p>

  <h2><span>Further reading</span></h2>

  <ul>
    <li>
      <a href="https://moz.com/blog/json-ld-for-beginners" target="_blank" rel="noopener">
        A Guide to JSON-LD for Beginners
      </a>
    </li>
    <li>
      <a href="https://www.forbes.com/sites/forbestechcouncil/2019/02/25/why-is-json-ld-important-to-businesses/amp/"
         target="_blank" rel="noopener">
        Why Is JSON-LD Important To Businesses?
      </a>
    </li>
    <li>
      <a href="https://json-ld.org/" target="_blank" rel="noopener">
        JSON for Linking Data - Official website
      </a>
    </li>
    <li>
      <a href="https://schema.org/docs/gs.html" target="_blank" rel="noopener">
        Getting started with schema.org using Microdata
      </a>
    </li>

    <li>
      <a href="https://search.google.com/structured-data/testing-tool/u/0/" target="_blank" rel="noopener">
        Google’s Structured Data Testing Tool
      </a>
    </li>

  </ul>

  <h2>
    <span>
      Special thanks to
    </span>
  </h2>

  <ul>
    <li>
      <a href="https://twitter.com/" rel="noopener" target="_blank"></a>
    </li>

  </ul>

  <p>for reviewing this post and providing valuable and much-appreciated feedback!</p>

</section>
